'use strict';

if (self.importScripts) {
  self.importScripts('/resources/testharness.js');
  self.importScripts('../resources/recording-streams.js');
}

const error1 = new Error('error1!');
error1.name = 'error1';

promise_test(t => {

  const rs = recordingReadableStream({
    start(controller) {
      controller.close();
    }
  });

  const ws = recordingWritableStream();

  return rs.pipeTo(ws).then(value => {
    assert_equals(value, undefined, 'the promise must fulfill with undefined')
  })
  .then(() => {
    assert_array_equals(rs.events, []);
    assert_array_equals(ws.events, ['close']);
  });

}, 'Closing must be propagated forward: starts closed; preventClose = false; fulfilled close promise');

promise_test(t => {

  const rs = recordingReadableStream({
    start(controller) {
      controller.close();
    }
  });

  const ws = recordingWritableStream({
    close() {
      throw error1;
    }
  });

  return promise_rejects(t, { name: 'error1' }, rs.pipeTo(ws), 'pipeTo must reject with the same error').then(() => {
    assert_array_equals(rs.events, []);
    assert_array_equals(ws.events, ['close']);
  });

}, 'Closing must be propagated forward: starts closed; preventClose = false; rejected close promise');

promise_test(t => {

  const rs = recordingReadableStream({
    start(controller) {
      controller.close();
    }
  });

  const ws = recordingWritableStream();

  return rs.pipeTo(ws, { preventClose: true }).then(value => {
    assert_equals(value, undefined, 'the promise must fulfill with undefined')
  })
  .then(() => {
    assert_array_equals(rs.events, []);
    assert_array_equals(ws.events, []);
  });

}, 'Closing must be propagated forward: starts closed; preventClose = true');

promise_test(t => {

  const rs = recordingReadableStream();

  const ws = recordingWritableStream();
  const writer = ws.getWriter();
  writer.close();
  writer.releaseLock();

  return rs.pipeTo(ws).then(
    () => assert_unreached('the promise must not fulfill'),
    err => {
      assert_equals(err.name, 'TypeError', 'the promise must reject with a TypeError');

      assert_array_equals(rs.eventsWithoutPulls, ['cancel', err]);
      assert_array_equals(ws.events, ['close']);
    }
  );

}, 'Closing must be propagated backward: starts closed; preventCancel = false; fulfilled cancel promise');

promise_test(t => {

  // Our recording streams do not deal well with errors generated by the system, so give them some help
  let recordedError;
  const rs = recordingReadableStream({
    cancel(cancelErr) {
      recordedError = cancelErr;
      throw error1;
    }
  });

  const ws = recordingWritableStream();
  const writer = ws.getWriter();
  writer.close();
  writer.releaseLock();

  return promise_rejects(t, { name: 'error1' }, rs.pipeTo(ws), 'pipeTo must reject with the same error').then(() => {
    assert_equals(recordedError.name, 'TypeError', 'the cancel reason must be a TypeError');

    assert_array_equals(rs.eventsWithoutPulls, ['cancel', recordedError]);
    assert_array_equals(ws.events, ['close']);
  });

}, 'Closing must be propagated backward: starts closed; preventCancel = false; rejected cancel promise');

promise_test(t => {

  const rs = recordingReadableStream();

  const ws = recordingWritableStream();
  const writer = ws.getWriter();
  writer.close();
  writer.releaseLock();

  return promise_rejects(t, new TypeError(), rs.pipeTo(ws, { preventCancel: true })).then(() => {
    assert_array_equals(rs.eventsWithoutPulls, []);
    assert_array_equals(ws.events, ['close']);
  });

}, 'Closing must be propagated backward: starts closed; preventCancel = true');
